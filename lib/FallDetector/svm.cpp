//
// Created by Zhenyi Ye on 2019-08-28.
//
#include "svm.h"

#define SCALE false


const float rho[] = {-0.27380828187154549};
const int label[] = {1, 0};
const int nr_sv[] = {28, 15};

const float yalpha1[28 * (NR_CLASS-1)] = {0.11346914464893285, 0.39131293563421971, 0.017568097161008683, 0.50012057182920777, 1.3, 0.05097625073176882, 0.069537862475028564, 1.2437388804056702, 0.26598904770225651, 0.058225561318520289, 0.075411315038744597, 0.066690341731630298, 1.3, 0.40076688586871206, 0.1975574278019063, 0.020565012398003221, 0.45088961233631825, 0.58081893375936056, 0.093495730698429036, 0.59025608331903656, 0.59676740866018818, 1.3, 0.042267161157680984, 0.37780586857724369, 0.57749865228350805, 1.3, 0.2296256282906497, 0.053337489373999181};

const float sv1[28 * VEC_DIM] = {0.6011574, 0.75, 5.2651189, 0.49249658, 0.15, 0.46666667, 0.7250386, 0, 1.1999709, 0.8, 9.0685905, 0.27348861, 0.1, 0.53333333, 0.42537181, 0, 1.6838381, 0.05, 3.6793873, 0.23142947, 0.15, 0.86666667, 0.47274173, 1, 3.6448979, 0.1, 11.762136, 0.19927933, 0.2, 0.8, 0.34385622, 1, 0.79014619, 0.65, 3.8621794, 0.1760215, 0.2, 0.93333333, 0.43059356, 2, 0.59978565, 0.55, 5.6800354, 0.35982742, 0.1, 0.6, 0.53044403, 0, 1.4265351, 0.05, 3.779069, 0.44275789, 0.15, 0.33333333, 0.98498127, 0, 0.91407075, 0.6, 4.2338785, 0.47112973, 0.2, 0.53333333, 1.1965926, 3, 1.5145266, 0.45, 6.1464623, 0.24000377, 0.1, 0.8, 1.9303505, 2, 1.6139772, 0.7, 10.446527, 0.41355008, 0.15, 0.73333333, 0.52155765, 1, 0.64443796, 0.2, 3.0555202, 0.11708599, 0.2, 0.86666667, 0.5612708, 1, 2.6347995, 0.05, 4.7638181, 0.45784504, 0.15, 0.93333333, 0.56088013, 1, 0.72333447, 0.55, 3.0707499, 0.10837589, 0.15, 0.86666667, 0.32005702, 2, 0.84890836, 0.1, 3.2058998, 0.27990166, 0.2, 0.8, 0.53543382, 0, 2.0818462, 0.2, 8.8811532, 0.2035824, 0.15, 0.6, 0.52446729, 1, 2.002134, 0.05, 4.9397609, 0.16522405, 0.15, 0.73333333, 0.316698, 0, 3.318791, 0.1, 6.8312648, 0.26743263, 0.2, 0.8, 0.45948035, 2, 3.9426381, 0.05, 5.2623997, 0.13939746, 0.1, 0.8, 0.31871054, 0, 1.3267386, 0.1, 4.2543123, 0.059239705, 0.15, 1, 0.28109496, 1, 3.83377, 0.3, 13.630496, 0.22544876, 0.1, 0.73333333, 0.48161251, 0, 1.5594115, 0.55, 7.1436563, 0.052346961, 0.2, 0.86666667, 0.57394612, 2, 0.6188235, 1.3, 4.3540064, 0.50980783, 0.15, 0.73333333, 0.71375375, 3, 2.0636516, 0.05, 4.8536136, 0.4651881, 0.15, 0.46666667, 0.72129689, 0, 0.49920515, 0.95, 6.9086795, 0.22766333, 0.2, 0.4, 0.33428102, 0, 0.93416999, 0.65, 11.58852, 0.2422735, 0.2, 0.6, 0.51047877, 1, 0.56429633, 1.15, 3.2213558, 0.48881282, 0.15, 0.8, 0.73075827, 3, 0.43920019, 1.7, 3.422869, 0.44292795, 0.15, 0.6, 0.80550303, 2, 0.50152661, 0.9, 3.9199307, 0.38238026, 0.15, 0.33333333, 0.83970155, 0};

const float yalpha2[15 * (NR_CLASS-1)] = {-0.28514487463204186, -0.80006222317529163, -0.56382932039321554, -0.99739212607165273, -0.66157707094674223, -1.3, -0.79466883690382906, -1.3, -0.20886261979811283, -0.7487801306331181, -0.65413317325818177, -1.3, -1.3, -0.050241527389838142, -1.3};

const float sv2[15 * VEC_DIM] = {1.4561457, 0.8, 5.5027941, 0.11568093, 0.1, 0.66666667, 0.71950801, 7, 1.5235762, 0.8, 8.6045637, 0.069976427, 0.1, 0.93333333, 0.43036845, 6, 0.75631253, 1.9, 3.0897864, 0.17403271, 0.1, 0.86666667, 0.62076003, 6, 0.6292948, 0.55, 3.4334364, 0.14779968, 0.2, 1, 0.38153573, 4, 1.4154835, 1.1, 6.9733264, 0.31512654, 0.15, 0.53333333, 0.92057458, 7, 0.74736636, 0.1, 3.1843826, 0.088157418, 0.2, 0.8, 0.26769609, 2, 1.5372602, 1.05, 7.1897296, 0.1496347, 0.15, 0.66666667, 0.54927855, 4, 1.0849325, 0.65, 4.4051991, 0.021162923, 0.1, 1, 0.19988493, 3, 1.3703095, 1.5, 8.1729536, 0.058598327, 0.1, 0.86666667, 0.26515388, 5, 1.3412001, 0.95, 5.8800138, 0.15484964, 0.1, 0.86666667, 0.50153054, 4, 0.87498587, 1.05, 4.5603591, 0.05923568, 0.15, 0.73333333, 0.53896264, 7, 0.75509571, 1.7, 3.7080683, 0.30402537, 0.1, 0.73333333, 0.86820518, 4, 0.60468003, 1.75, 3.0740522, 0.088158771, 0.2, 0.86666667, 0.53528174, 3, 1.2199651, 1.4, 5.7774073, 0.132219, 0.1, 0.8, 0.66866406, 7, 0.6570578, 0.75, 3.7833414, 0.25250479, 0.25, 0.86666667, 0.43178483, 2};

const int scalePar[] = {0,1};
const float low[] = {0.2513363238762476,0,3.0096612277234418,0.040740040972187634,0.10000000000000001,0,0.21980835135333585,0};
const float high[] = {6.091244539164772,2.1499999999999999,13.820276067328857,1.1322956089815623,0.90000000000000002,1,4.4580199082376435,8};

int result[NR_CLASS]={0};

float const* const supportVectors[NR_CLASS] = {
        sv1, sv2, };
const float* const valuesForSupport[NR_CLASS] = {
        yalpha1, yalpha2, };

void scale(const float* sensor, float* scaledSensor){
    if(SCALE)
        for(int p=0; p<VEC_DIM;p++){
            scaledSensor[p] = (float)scalePar[0] +((float)scalePar[1] -((float)scalePar[0]))*((float)sensor[p]-(float)low[p])/((float)high[p]-(float)low[p]);
        }
    else
        for(int p=0; p<VEC_DIM; p++){
            *(scaledSensor+p) = sensor[p];
        }
}

uint8_t svm_predict(float sensor[]){
    int recognizedClass = 1;
    float scaledSensor[VEC_DIM];

    scale(sensor,scaledSensor);
    int rhoCounter = 0;

    for(int i=0; i<NR_CLASS; i++){
        for(int j=i+1; j<NR_CLASS; j++){
            float accumulator = 0;

            float* sv_class1 = (float*) (supportVectors[i]);
            float* sv_class2 = (float*) (supportVectors[j]);
            float* coeffs1   = (float*) (valuesForSupport[i]) + nr_sv[i] * (j-1);
            float* coeffs2   = (float*) (valuesForSupport[j]) + nr_sv[j] * i;


            Serial.println("sv_1");
            accumulator += svm_evaluate(nr_sv[i], coeffs1, sv_class1, scaledSensor);
            Serial.println("sv_2");
            accumulator += svm_evaluate(nr_sv[j], coeffs2, sv_class2, scaledSensor);


            float rhoNr = *(rho + rhoCounter);
            accumulator -= rhoNr;


            if (accumulator > 0) {
                result[i]++;
            } else {
                result[j]++;
            }
            rhoCounter++;
        }

    }


    int temp = 0;
    for(int t = 0; t < NR_CLASS; t++){
        Serial.println(result[t]);
        if(result[temp] <= result[t]){
            recognizedClass = label[t];
            temp = t;
        }
    }

    Serial.print("result: ");
    Serial.println(recognizedClass, DEC);
    delay(500);
    for(int q = 0; q < NR_CLASS; q++){
        result[q]=0;
    }
    return recognizedClass;
}

inline float svm_evaluate(int n_sv, float* coeffs, float* sv_class, float* sensors){
    float result= 0;
    float* sv_current = sv_class;
    for (int i=0; i<n_sv; i++, sv_current += VEC_DIM){
        Serial.print(*(coeffs + i), 5);
        Serial.print(' ');
        float coeff = *(coeffs + i);
#ifdef GAMMA
        float temp = coeff * rbf_kernel(sv_current, sensors);
#else
        float temp = coeff * linear_kernel(sv_current, sensors);
#endif
        result += temp;
        Serial.print(temp, 8);
        Serial.println();
    }
    Serial.println(result, 5);
    Serial.println(' ');
    return result;

}


inline float linear_kernel(float* u, float* v){
    float result=0;
    for (int j=0; j<VEC_DIM; j++){
        Serial.println(v[j]);
        result += *(u + j) * v[j];
        //
        //
    }
    Serial.print(result, 5);
    Serial.print(' ');
    //Serial.print();
    return result;
}

float rbf_kernel(float* u, float* v){
    float result=0;
    for (int j=0; j<VEC_DIM; j++){
        float temp = *(u + j) - v[j];
        result += temp * temp;
    }
    return exp(-GAMMA * result);
}